// Create the canvas
var canvas = document.getElementById("dbCanvas");
var ctx = canvas.getContext("2d");
// constants
var intNUMBEROFCOLORS = 5;
var intNUMBEROFROWS = 10;
var intNUMBEROFCOLUMNS = 15;
var intCOLUMNTWO = 680;
var intWIDTH = 27;
var intHEIGHT = 33;
var intREADY = 0;
var intSELECTED = 1;
var intPOPPED = 2;
var colors = [[getColorDARKRED(), getColorDARKGREEN(), getColorMAGENTA(), getColorDARKBLUE(), getColorORANGE()],
					[getColorLIGHTPINK(), getColorLIGHTGREEN(), getColorLIGHTMAGENTA(), getColorLIGHTBLUE(), getColorYELLOW()]];
var selects = [];
var columns = [];
var historyQueue = [];
var intPositions = [];
var intLevel;
var intRightMost;
var intPoints;
var intMoves;
var intBalloons;
var	intHighestScore;
var intLowestCount;
var boolPopping = false;
canvas.addEventListener("mousemove", mouseMove);
canvas.addEventListener("click", mouseClick);
reInit();

// objBalloon constructor
function objBalloon(row, col) 
{
	this.row = this.rowOrig = row;
	this.col = this.colOrig = col;
	this.color = getIntRnd(intNUMBEROFCOLORS - 1);			// will yield 0 through 4
	this.x = (this.col + 1) * 1.5 * intWIDTH;		
	this.y = (this.row + 1) * 1.75 * intHEIGHT;
	this.state = intREADY;
	this.setCol = function(newcol)
	{
		this.col = newcol;
		this.x = (this.col + 1) * 1.5 * intWIDTH;		
	}	
	this.setRow = function(newrow)
	{
		this.row = newrow;
		this.y = (this.row + 1) * 1.75 * intHEIGHT;
	}		
	this.draw = function() 
	{
		if (this.state == intPOPPED)
		{
			return;
		}	
		ctx.beginPath();
		ctx.ellipse(this.x, this.y, intWIDTH * .75, intWIDTH, 0, 0, 2 * Math.PI);
		ctx.fillStyle = colors[this.state][this.color];
		ctx.fill();
		ctx.beginPath();
		ctx.moveTo(this.x, this.y + intHEIGHT - 7);
		ctx.lineTo(this.x + 3, this.y + intHEIGHT - 2);
		ctx.lineTo(this.x - 3, this.y + intHEIGHT - 2);
		ctx.closePath();
		ctx.fill();
		ctx.beginPath();
		ctx.fillStyle = getColorWHITE();
		ctx.fillRect(this.x + 5, this.y - 15, 3, 4);
		printText(this.row + ", " + this.col, this.x - 10, this.y, getColorWHITE(), 12);
	}
	this.display = function()
	{
		return "Row=" + this.row + ", col=" + this.col + ", color=" + this.color + ", state=" + this.state;
	}	
	this.hit = function()
	{
		if (currentX >= this.x - (intWIDTH * 3/4) && currentX <= this.x + (intWIDTH * 3/4))
		{
			if (currentY >= this.y - (intHEIGHT * 3/4) && currentY <= this.y + intHEIGHT)
			{
				if (this.state < intPOPPED)
				{
					return true;	
				}
				return false;	
			}
		}
		return false;
	}
}
// objColumn -- a column of objBalloons
function objColumn(col)
{
	this.column = col;
	this.active = true;
	this.balloons = [];
	this.positions = [];
	for (var r = 0; r < intNUMBEROFROWS; r++)
	{
		this.balloons[r] = new objBalloon(r, this.column);
		this.positions[r] = r;
	}
	this.lowest = intNUMBEROFROWS - 1;
	this.reNumber = function()
	{
		var pos = 0;
		for (var r = 0; r < intNUMBEROFROWS; r++)
		{	
			if (this.balloons[r].state != intPOPPED)
			{
				console.log("In renumber, looking at " + this.balloons[r].display());
				this.positions[pos] = r;
				this.balloons[r].setRow(pos++);
				console.log("After renumber, " + this.balloons[r].display());
			}
		}
		this.lowest = pos - 1;
		this.active = (this.lowest < 0) ? false : true;
	}
	this.display = function()
	{
		console.log("Column " + this.column);
		for (var i = 0; i < this.balloons.length; i++)
		{
			this.balloons[i].display();
		}
	}		
	this.setColumn = function(c)
	{
		this.column = c;
		for (var r = 0; r < intNUMBEROFROWS; r++)
		{	
			this.balloons[r].setCol(c);
		}
	}
}	
function mouseClick(event)
{
	//pop whatever was in selects
	boolPopping = true;
	if (selects.length > 0)
	{
		historyQueue[historyQueue.length] = selects;
		intMoves += 1;
		var p = (selects.length * selects.length * intLevel);
		intPoints += p;
		stringMessage = "" + p + " points!";
//		getHighestScore(points + getBonus());
		for (var i = 0; i < selects.length; i++)
		{	
			intBalloons -= 1;
			selects[i].state = intPOPPED;
			console.log("Took balloon " + selects[i].display());
			columns[selects[i].col].reNumber();
//			columns[intPositions[selects[i].col]].reNumber();
		}	
		reNumber();
	}
	boolPopping = false;	
}
function reNumber()
{
	var pos = 0;
	for (var c = 0; c < intNUMBEROFCOLUMNS; c++)
	{	
		if (columns[c].active == true)
		{
			intPositions[pos] = c;
			columns[c].setColumn(pos);
			pos++;
		}
	}
	intRightMost = pos - 1;
	selects = [];
	if (intBalloons == 0)
	{	
		intPoints += 2500 * level;
		intLevel += 1;
		reInit();
	}
}
function findHoverBalloon()
{
	selects = [];
	for (var c = 0; c <= intRightMost; c++)
	{
		var bcol = columns[intPositions[c]];
		for (var r = 0; r <= bcol.lowest; r++)
		{
			if (bcol.balloons[r].hit(currentX, currentY) == true)
			{
				addToSelects(bcol.balloons[r]);
				return;
			}	
		}
	}
	selects = [];	
}		
function mouseMove(event)
{
	if (boolPopping === false)
	{
		var rect = canvas.getBoundingClientRect();
		currentX = event.clientX - rect.left;
		currentY = event.clientY - rect.top;
		//deselect whatever was in selects
		for (var i = 0; i < selects.length; i++)
		{	
			selects[i].state = intREADY;
		}	
		findHoverBalloon();
		if (selects.length > 0)
		{
			var sels = 0;
			// check the ones around the selected one
			while (selects.length > sels)
			{
				//get its position
				var c = selects[sels].col;
				var r = selects[sels].row;
				//check north
				if (r > 0)
				{	
					if (columns[c].balloons[r - 1].color === selects[sels].color)
					{
						if (columns[c].balloons[r - 1].state == intREADY)
						{
							addToSelects(columns[c].balloons[r - 1]);
						}	
					}	
				}	
				//check south
				if (r < (columns[intPositions[c]].lowest))
				{	
					if (columns[c].balloons[r + 1].color === selects[sels].color)
					{
						if (columns[c].balloons[r + 1].state == intREADY)
						{
							addToSelects(columns[c].balloons[r + 1]);
						}	
					}	
				}
				//check west
				if (c > 0 && (r <= columns[intPositions[c - 1]].lowest))
				{	
					if (columns[c - 1].balloons[r].color === selects[sels].color)
					{
						if (columns[c - 1].balloons[r].state == intREADY)
						{
							addToSelects(columns[c - 1].balloons[r]);
						}	
					}	
				}
				//check east
				if (c < intRightMost && (r <= columns[intPositions[c + 1]].lowest))
				{	
					if (columns[c + 1].balloons[r].color === selects[sels].color)
					{
						if (columns[c + 1].balloons[r].state == intREADY)
						{
							addToSelects(columns[c + 1].balloons[r]);
						}	
					}	
				}
				sels++;
			}
			if (selects.length < 2)
			{
				selects[0].state = intREADY;
				selects = [];
			}
		}
	}	
}
function addToSelects(balloon)
{
	balloon.state = intSELECTED;
	selects[selects.length] = balloon;
}	

function printText(string, x, y, color, sz)
{
	ctx.font = sz + "px Arial";
	ctx.textAlign = "left";
	ctx.textBaseline = "top";
	ctx.fillStyle = color;
	ctx.fillText(string, x, y);
}
// Draw everything
function render() 
{
	ctx.fillStyle = getColorCREAM();
	ctx.fillRect(0,0,canvas.width,canvas.height);
	for (var c = 0; c <= intRightMost; c++)
	{
		var bcol = columns[intPositions[c]];
		for (var r = 0; r <= bcol.lowest; r++)
		{
			bcol.balloons[r].draw();
		}
	}
	printText(stringMessage, intCOLUMNTWO, 10, getColorDARKGREEN(), 16);	
	printText("Level: " + intLevel, intCOLUMNTWO, 50, getColorBLACK(), 32);
	printText("Points: " + intPoints, intCOLUMNTWO, 90, getColorBLACK(), 32);
	printText("Selected: " + selects.length, intCOLUMNTWO, 130, getColorBLACK(), 32);
	printText("Moves: " + intMoves, intCOLUMNTWO, 170, getColorBLACK(), 32);
	printText("Bonus: " , intCOLUMNTWO, 210, getColorBLACK(), 32);
	printText("Total: " , intCOLUMNTWO, 250, getColorBLACK(), 32);
	printText("High: " , intCOLUMNTWO, 290, getColorBLACK(), 32);
	printText("Balloons: " + intBalloons, intCOLUMNTWO, 330, getColorBLACK(), 32);
}
function reInit()
{
	for (var c = 0; c < intNUMBEROFCOLUMNS; c++)
	{
		columns[c] = new objColumn(c);
		intPositions[c] = c;
	}
	selects = [];
	intRightMost = intNUMBEROFCOLUMNS - 1;
	intBalloons = intLowestCount = intNUMBEROFCOLUMNS * intNUMBEROFROWS;
	historyQueue = [];
	intMoves = 0;
	intHighestScore = 0;
	intPoints = 0;
	intLevel = 1;
}	
// The main game loop
function main() 
{
	render();
	// Request to do this again ASAP
	requestAnimationFrame(main);
};
// Cross-browser support for requestAnimationFrame
var w = window;
requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;
// Let's play this game!
main();